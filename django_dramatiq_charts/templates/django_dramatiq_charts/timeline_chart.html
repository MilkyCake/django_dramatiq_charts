{% extends "django_dramatiq_charts/base.html" %}

{% block title %}Dramatiq task timeline chart{% endblock %}

{% block description %}Dramatiq task timeline chart{% endblock %}

{% block extrahead %}
    <script src='{{ plotly_lib }}'></script>
    <style>
        body {
            padding-right: 0.6em;
            padding-left: 0.6em;
        }
        input, select {
            margin: 0 1em 0.38em 0.3em;
        }
        .errorlist {
            color: red;
            list-style: none;
        }
    </style>
{% endblock %}

{% block content %}
    <form method="GET" style="text-align: center; margin-bottom: 0.38em;">
        {{ form }}
        <button type="submit">Build chart</button>&nbsp;
        <a href="."><i>Reset</i></a>&nbsp;
        <a href="{% url 'update_cache' %}?redirect={{ request.get_full_path|urlencode }}"><i>Update cache</i></a>
    </form>
    {% if empty_qs %}
        <p style="font-size: 2em; text-align: center">üîç there is no data for the specified criteria</p>
    {% elif chart_data %}
        <div id='chart'></div>
    {% else %}
        <p style="font-size: 2em; text-align: center">üñ¶ select build criteria</p>
    {% endif %}
{% endblock %}

{% block extrabottom %}
    <script>
        function statusColor(status) {
            // color definition for status
            switch (status) {
                case 'enqueued': return 'rgb(142, 40, 252)';
                case 'delayed': return 'rgb(180, 180, 180)';
                case 'running': return 'rgb(99, 110, 250)';
                case 'failed': return 'rgb(239, 85, 59)';
                case 'done': return 'rgb(0, 204, 150)';
                case 'skipped': return 'rgb(100, 100, 100)';
            }
        }

        function msToString(milliseconds) {
            // converting milliseconds -> hours: minutes: seconds: milliseconds
            let ms = Math.round(milliseconds % 1000) + 'ms';
            let s = Math.floor((milliseconds / 1000) % 60) + 's';
            let m = Math.floor((milliseconds / (1000 * 60)) % 60) + 'm';
            let h = Math.floor((milliseconds / (1000 * 60 * 60)) % 24) + 'h';
            let time = '';
            [h, m, s, ms].forEach(function (t) {
                if (/[1-9]/.test(t)) {
                    time += t + ' ';
                }
            });
            return time;
        }

        let chart_data = {{ chart_data|safe|default:'[]' }};
        let filter_data = {{ filter_data|safe|default:'[]' }};
        let data = [];
        let unique_actors = new Set();
        let unique_statuses = [];
        let bargap = 2;    // indent between intervals in fractions of the interval width by y
        let chart = document.getElementById('chart');

        chart_data.forEach(function (task) {
            unique_actors.add(task['actor']);
            let y = unique_actors.size * bargap;
            let x_start = (task['start'] > filter_data['start_date']) ? task['start'] : filter_data['start_date'];
            let x_end = (task['end'] < filter_data['end_date']) ? task['end'] : filter_data['end_date'];
            let color = statusColor(task['status']);
            let duration = msToString(task['duration']);
            let text = `Task: ${task['actor']}<br>` +
                       `Status: <span style="color:${color}">${task['status']}</span><br>` +
                       `Duration: ${duration}<br>` +
                       `Start: ${task['start'].slice(0, -3)}<br>` +
                       `End: ${task['end'].slice(0, -3)}`;
            data.push({
                x: [x_start, x_start, x_end, x_end, x_start],
                y: [y - 0.5, y + 0.5, y + 0.5, y - 0.5, y - 0.5],
                mode: 'lines',
                line: {
                    color: color,
                    width: 1,
                },
                fill: 'toself',
                name: task['status'],
                group: task['status'],
                text: text,
                hoveron: 'all',
                hoverinfo: 'text',
                legendgroup: task['status'],
                customdata: {
                    actor: task['actor'],
                    mode: 'overlay',
                },
            });

            // adding only unique statuses to the legend
            if (unique_statuses.includes(task['status'])) {
                data[data.length - 1]['showlegend'] = false;
            } else {
                data[data.length - 1]['showlegend'] = true;
                unique_statuses.push(task['status']);
            }
        });

        // array of ticks for actor names
        let y_tickvals = [];
        for (let tick = bargap; tick <= unique_actors.size * bargap; tick += bargap) {
            y_tickvals.push(tick);
        }

        let layout = {
            title: {
                text: {{ chart_title|safe|default:"''" }},
                font: {
                    size: 15,
                }
            },
            xaxis: {
                range: [filter_data['start_date'], filter_data['end_date']],
            },
            yaxis: {
                zeroline: false,
                automargin: true,
                tickmode: 'array',
                tickvals: y_tickvals,
                ticktext: [...unique_actors],
            },
            legend: {
                title: {
                    text: `Status<br>`,
                }
            },
            hoverlabel: {
                bgcolor: '#eaeaea',
            },
            height: Math.min(Math.max(200 + unique_actors.size * 100, 300), 900),    // min - 300px, max - 900px
            hovermode: 'closest',    // not working
            hoverdistance: 1000,    // not working
        };

        if (data.length > 0) {
            Plotly.newPlot(chart, data, layout);
        }

        let drag_layer = document.getElementsByClassName('nsewdrag')[0];    // cursor object

        chart.on('plotly_click', function (eventdata) {    // uncovering of tasks within a single actor
            let current_actor = eventdata.points[0].data.customdata['actor'];
            let mode = eventdata.points[0].data.customdata['mode'];
            if (mode === 'overlay') {
                let data_single = [];
                let unique_statuses_single = [];
                let y = bargap;
                console.log(data)
                data.forEach(function (task) {
                    if (task['customdata']['actor'] === current_actor) {
                        data_single.push(Object.assign({}, task, {
                            customdata: {    // it might be {}
                                actor: current_actor,
                                mode: 'group',
                            },
                            y: [y - 0.5, y + 0.5, y + 0.5, y - 0.5, y - 0.5],
                        }))
                        y += bargap;
                        if (unique_statuses_single.includes(task['group'])) {
                            data_single[data_single.length - 1]['showlegend'] = false;
                        } else {
                            data_single[data_single.length - 1]['showlegend'] = true;
                            unique_statuses_single.push(task['group']);
                        }
                    }
                })
                console.log(data_single)

                let layout_single = Object.assign({}, layout, {
                    title: {
                        text: {{ chart_title|safe|default:"''" }} + `<br><br>Tasks for ${current_actor}`,
                        font: {
                            size: 15,
                        }
                    },
                    yaxis: {
                        zeroline: false,
                        automargin: true,
                        tickmode: 'array',
                        tickvals: [y / 2],
                        ticktext: [current_actor],
                    },
                    height: 700,
                })
                Plotly.react(chart, data_single, layout_single);
            }
            else {
                Plotly.react(chart, data, layout);
            }
        })
        .on('plotly_hover', function () {    // the cursor changes when hovering over an interval
            drag_layer.style.cursor = 'pointer';
        })
        .on('plotly_unhover', function () {
            drag_layer.style.cursor = '';
        });

    </script>
{% endblock %}
