{% extends "django_dramatiq_charts/base.html" %}

{% block title %}Dramatiq task timeline chart{% endblock %}

{% block description %}Dramatiq task timeline chart{% endblock %}

{% block extrahead %}
    <script src='{{ plotly_lib }}'></script>
    <style>
        body {
            padding-right: 0.6em;
            padding-left: 0.6em;
        }
        input, select {
            margin: 0 1em 0.38em 0.3em;
        }
        .errorlist {
            color: red;
            list-style: none;
        }
    </style>
{% endblock %}

{% block content %}
    <form method="GET" style="text-align: center; margin-bottom: 0.38em;">
        {{ form }}
        <button type="submit" class="button-form">Build chart</button>&nbsp;
        <a href="."><i>Reset</i></a>&nbsp;
        {% if cache_enabled %}
            <a href="{% url 'update_cache' %}"><i>Update cache</i></a>
        {% endif %}
    </form>
    {% if empty_qs %}
        <p style="font-size: 1.7em; text-align: center">üîç there is no data for the specified criteria</p>
    {% elif chart_data %}
        <div id='chart'></div>
    {% else %}
        <p style="font-size: 1.7em; text-align: center">üñ¶ select build criteria</p>
    {% endif %}
{% endblock %}

{% block extrabottom %}
    <script>
        function statusColor(status) {
            // color definition for status
            switch (status) {
                case 'enqueued': return 'rgb(142, 40, 252)';
                case 'delayed': return 'rgb(180, 180, 180)';
                case 'running': return 'rgb(99, 110, 250)';
                case 'failed': return 'rgb(239, 85, 59)';
                case 'done': return 'rgb(0, 204, 150)';
                case 'skipped': return 'rgb(100, 100, 100)';
            }
        }

        function msToString(milliseconds) {
            // converting milliseconds -> hours: minutes: seconds: milliseconds
            if (milliseconds <= 0) {
                return 'undefined';
            }
            let ms = Math.round(milliseconds % 1000) + 'ms';
            let s = Math.floor((milliseconds / 1000) % 60) + 's';
            let m = Math.floor((milliseconds / (1000 * 60)) % 60) + 'm';
            let h = Math.floor(milliseconds / (1000 * 60 * 60)) + 'h';
            let time = '';
            [h, m, s, ms].forEach(function (t) {
                if (/[1-9]/.test(t)) {
                    time += t + ' ';
                }
            });
            return time;
        }

        function heightCalculator(count, width, extra, min, max) {
            // calculating the chart height depending on the parameters:
            // count - number of data instances, width - width of the instance with a gap,
            // extra - additional height, min - minimum height, max - maximum height
            extra = extra || 0;
            let height = extra + count * width;
            if (min) {
                height = Math.max(height, min);
            }
            if (max) {
                height = Math.min(height, max);
            }
            return height;
        }

        let chart_data = {{ chart_data|safe|default:'[]' }};
        let filter_data = {{ filter_data|safe|default:'[]' }};
        let data = [];
        let unique_actors = new Set();
        let unique_statuses = [];
        let bargap = 1.25;    // indent between intervals in fractions of the interval width by y
        let chart = document.getElementById('chart');

        chart_data.forEach(function (task) {
            unique_actors.add(task['actor']);
            let y = unique_actors.size * bargap;
            let x_start = new Date(
                (task['start'] > filter_data['start_date']) ? task['start'] : filter_data['start_date']
            );
            let x_end = new Date(task['end']);
            // show momental as 1 sec when the duration is less than 1 sec
            if (task['duration'] < 1000) {
                x_end = new Date(x_start.getTime() + 1000);
            }
            x_end = (x_end < new Date(filter_data['end_date'])) ? x_end : new Date(filter_data['end_date']);
            let color = statusColor(task['status']);
            let duration = msToString(task['duration']);
            let text = `Task: ${task['actor']}<br>` +
                       `Status: <span style="color:${color}">${task['status']}</span><br>` +
                       `Duration: ${duration}<br>` +
                       `Start: ${task['start'].slice(0, -3)}<br>` +
                       `End: ${task['end'].slice(0, -3)}`;
            data.push({
                x: [x_start, x_start, x_end, x_end, x_start],
                y: [y - 0.5, y + 0.5, y + 0.5, y - 0.5, y - 0.5],
                type: 'scatter',
                mode: 'lines',
                line: {
                    color: color,
                    width: 1,
                },
                fill: 'toself',
                name: task['status'],
                group: task['status'],
                text: text,
                hoveron: 'all',
                hoverinfo: 'text',
                legendgroup: task['status'],
                customdata: {
                    actor: task['actor'],
                    mode: 'overlay',
                },
            });

            // adding only unique statuses to the legend
            if (unique_statuses.includes(task['status'])) {
                data[data.length - 1]['showlegend'] = false;
            } else {
                data[data.length - 1]['showlegend'] = true;
                unique_statuses.push(task['status']);
            }
        });

        // array of ticks for actor names
        let y_tickvals = [];
        for (let tick = bargap; tick <= unique_actors.size * bargap; tick += bargap) {
            y_tickvals.push(tick);
        }

        let layout = {
            title: {
                text: {{ chart_title|safe|default:"''" }},
                font: {
                    size: 15,
                }
            },
            xaxis: {
                range: [filter_data['start_date'], filter_data['end_date']],
            },
            yaxis: {
                zeroline: false,
                automargin: true,
                tickmode: 'array',
                tickvals: y_tickvals,
                ticktext: [...unique_actors],
            },
            legend: {
                title: {
                    text: `Status<br>`,
                }
            },
            hoverlabel: {
                bgcolor: '#eaeaea',
            },
            height: heightCalculator(unique_actors.size, 30, 300),
        };

        if (data.length > 0) {
            Plotly.newPlot(chart, data, layout);
        }

        let drag_layer = document.getElementsByClassName('nsewdrag')[0];    // cursor object

        // uncovering of tasks within a single actor
        chart.on('plotly_click', function (eventdata) {
            let current_actor = eventdata.points[0].data.customdata['actor'];
            let mode = eventdata.points[0].data.customdata['mode'];
            if (mode === 'overlay') {
                let data_single = [];
                let unique_statuses_single = [];
                let y = bargap;
                data.forEach(function (task) {
                    if (task['customdata']['actor'] === current_actor) {
                        data_single.push(Object.assign({}, task, {
                            customdata: {
                                actor: current_actor,
                                mode: 'group',
                            },
                            y: [y - 0.5, y + 0.5, y + 0.5, y - 0.5, y - 0.5],
                        }))
                        y += bargap;
                        if (unique_statuses_single.includes(task['group'])) {
                            data_single[data_single.length - 1]['showlegend'] = false;
                        } else {
                            data_single[data_single.length - 1]['showlegend'] = true;
                            unique_statuses_single.push(task['group']);
                        }
                    }
                });

                let layout_single = Object.assign({}, layout, {
                    title: {
                        text: {{ chart_title|safe|default:"''" }} + `<br><br>Tasks for ${current_actor}`,
                        font: {
                            size: 15,
                        }
                    },
                    yaxis: {
                        zeroline: false,
                        automargin: true,
                        tickmode: 'array',
                        tickvals: [y / 2],
                        ticktext: [current_actor],
                    },
                    height: heightCalculator(data_single.length, 15, 350),
                });
                Plotly.react(chart, data_single, layout_single);
            }
            else {
                Plotly.react(chart, data, layout);
            }
        })
        .on('plotly_hover', function () {
            // the cursor changes when hovering over an interval
            drag_layer.style.cursor = 'pointer';
        })
        .on('plotly_unhover', function () {
            drag_layer.style.cursor = '';
        });
    </script>
{% endblock %}